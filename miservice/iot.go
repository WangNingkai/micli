package miservice

import (
	"crypto/rc4"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path"
	"strings"
)

func parseDesc(desc string) (string, string) {
	name := ""
	specialChars := "-—{「[【(（<《"
	for _, d := range desc {
		if strings.ContainsRune(specialChars, d) {
			return name, "  # " + desc[len(name)+1:]
		}
		if d == ' ' {
			name += "_"
		} else {
			name += string(d)
		}
	}
	return name, ""
}

func makeLine(siid, iid int, desc, comment string, readable bool, format string) string {
	var value string
	if format == "python" {
		value = fmt.Sprintf("(%d, %d)", siid, iid)
	} else {
		value = fmt.Sprintf("%d", iid)
	}

	prefix := ""
	if !readable {
		prefix = "_"
	}

	return fmt.Sprintf("    %s%s = %s%s\n", prefix, desc, value, comment)
}

func getSpec(kind string, specs map[string]string) map[string]string {
	if kind == "" {
		return specs
	}
	var ret = make(map[string]string)
	for k, v := range specs {
		if k == kind {
			return map[string]string{k: v}
		} else if strings.Contains(k, kind) {
			ret[k] = v
		}
	}
	return ret
}

func loadSpec(p string) (map[string]string, error) {
	f, err := os.Open(p)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	j := json.NewDecoder(f)
	var specs map[string]string
	err = j.Decode(&specs)
	if err != nil {
		return nil, err
	}
	return specs, nil
}

type MiotSpecInstances struct {
	Instances []struct {
		Status  string `json:"status"`
		Model   string `json:"model"`
		Version int    `json:"version"`
		Type    string `json:"type"`
		Ts      int    `json:"ts"`
	} `json:"instances"`
}

type MiotSpecInstancesData struct {
	Type        string `json:"type"`
	Description string `json:"description"`
	Services    []struct {
		Iid         int    `json:"iid"`
		Type        string `json:"type"`
		Description string `json:"description"`
		Properties  []struct {
			Iid         int      `json:"iid"`
			Type        string   `json:"type"`
			Description string   `json:"description"`
			Format      string   `json:"format"`
			Access      []string `json:"access"`
			ValueList   []struct {
				Value       int    `json:"value"`
				Description string `json:"description"`
			} `json:"value-list,omitempty"`
			ValueRange []int `json:"value-range,omitempty"`
		} `json:"properties,omitempty"`
		Actions []struct {
			Iid         int           `json:"iid"`
			Type        string        `json:"type"`
			Description string        `json:"description"`
			In          []interface{} `json:"in"`
			Out         []interface{} `json:"out"`
		} `json:"actions,omitempty"`
	} `json:"services"`
}

func (s *IOService) IotSpec(kind string) (string, error) {
	if kind == "" || !strings.HasPrefix(kind, "urn") {
		p := path.Join(os.TempDir(), "miot-spec.json")
		specs, err := loadSpec(p)
		if err != nil {
			var rr *http.Response
			rr, err = s.account.client.Get("http://miot-spec.org/miot-spec-v2/instances?status=all")
			if err != nil {
				return "", err
			}
			defer rr.Body.Close()
			var instanceSpec *MiotSpecInstances
			err = json.NewDecoder(rr.Body).Decode(&instanceSpec)
			if err != nil {
				return "", err
			}
			specs = make(map[string]string)
			for _, v := range instanceSpec.Instances {
				specs[v.Model] = v.Type
			}
			var f *os.File
			f, err = os.Create(p)
			if err == nil {
				defer f.Close()
				_ = json.NewEncoder(f).Encode(specs)
			}
		}
		specs = getSpec(kind, specs)
		if len(specs) != 1 {
			instances := make([]string, 0, len(specs))
			for _, v := range specs {
				instances = append(instances, v)
			}
			// todo: return error
			return "", fmt.Errorf("found %d instances: %s", len(specs), strings.Join(instances, ", "))
		}
		for _, v := range specs {
			kind = v
			break
		}
	}
	u := "http://miot-spec.org/miot-spec-v2/instance?type=" + kind
	rs, err := s.account.client.Get(u)
	if err != nil {
		return "", err
	}
	defer rs.Body.Close()
	var result *MiotSpecInstancesData
	err = json.NewDecoder(rs.Body).Decode(&result)
	if err != nil {
		return "", err
	}
	fmt.Println(result)
	/*var (
		text string
	)
	text = fmt.Sprintf("# Generated by imwnk\n#%s\n", u)
	services := result.Services
	svcs := make([]string, 0)
	vals := make([]map[string]interface{}, 0)
	for _, service := range services {
		svc := service.Description
		siid := service.Iid
		svc = strings.ReplaceAll(svc, " ", "_")
		svcs = append(svcs, svc)
		text += fmt.Sprintf(STR_SRV, svc, siid)
		properties := service.Properties
		for _, p := range properties {
			name, comment := parseDesc(p.Description)
			access := p.Access
			strArr := make([]string, 0)
			readable := false
			for _, v := range access {
				if v == "read" {
					readable = true
				}
				strArr = append(strArr, v[0:1])
			}
			comment += strings.Join(strArr, "")
			text += makeLine(siid, p.Iid, name, comment, readable, "")
			values := make(map[string]interface{})
			if p.ValueRange != nil {
				values["MIN"] = p.ValueRange[0]
				values["MAX"] = p.ValueRange[1]
				if len(p.ValueRange) > 2 {
					values["STEP"] = p.ValueRange[2]
				}
			}
			if p.ValueList != nil {
				for _, item := range p.ValueList {
					description := item.Description
					if description != "" {
						values[strings.ReplaceAll(description, " ", "_")] = item.Value
					} else {
						values[strconv.Itoa(item.Value)] = item.Value
					}
				}
			}
			vals = append(vals, values)
		}
		text += "\n"
		for _, action := range service.Actions {
			name, comment := parseDesc(action.Description)
			pStr := "# "
			if action.In != nil {
				pStr += strings.Join(action.In, ",")
			}

			if action.Out != nil {
				pStr += strings.Join(action.Out, ",")
			}
			comment += pStr
			text += makeLine(siid, action.Iid, name, comment, false, "")

		}
		text += "\n"
	}*/

	return "", nil
}

func (s *IOService) IotDecode(ssecurity string, nonce string, data string, gzip bool) (interface{}, error) {
	signNonceStr, err := signNonce(ssecurity, nonce)
	if err != nil {
		return nil, err
	}
	key, err := base64.StdEncoding.DecodeString(signNonceStr)
	if err != nil {
		return nil, err
	}
	cipher, err := rc4.NewCipher(key)
	if err != nil {
		return nil, err
	}

	cipher.XORKeyStream(key[:1024], key[:1024])

	encryptedData, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil, err
	}
	decrypted := make([]byte, len(encryptedData))
	cipher.XORKeyStream(decrypted, encryptedData)

	if gzip {
		decrypted, err = unzip(decrypted)
		if err != nil {
			return nil, err
		}
	}

	var result interface{}
	err = json.Unmarshal(decrypted, &result)
	if err != nil {
		return nil, err
	}
	return result, nil
}
